
# `data.frames` {#dataframes}

Wir haben gelernt, dass `R` Daten in Vektoren abspeichert. Im Normalfall
haben wir in der psychometrischen Datenauswertung aber eine große
Datenmenge vorliegen, die wir nicht sinnvoll als einzelnen Vektor
darstellen können. Etwa: 150 Studierende bearbeiten in einer
Diagnostikklausur 42 Multiple-Choice-Klausuritems. Wir stellen solche
Daten in Tabellen dar, wie man sie auch aus Excel oder SPSS kennt. In
diesen Tabellen repräsentieren Spalten Messvariablen, etwa die
Punktzahlen in einer Klausuraufgabe. Zeilen stellen Fälle dar, etwa
Personen, die an der Klausur teilgenommen haben. Andere Datenformate
wären auch denkbar, etwa eines bei dem jede Zeile einer Antwort
entspricht. Bei uns wird aber gelten: Jede Zeile entspricht genau einer
Person.

In `R` speichern wir Datentabellen in `data.frames` ab. Ein `data.frame`
ist, vereinfacht gesagt, eine Sammlung von Vektoren gleicher Länge.
Jede Spalte -- also jede Messvariable -- ist ein Vektor. Mit dieser
Datenstruktur werden wir uns im vorliegenden Kapitel auseinandersetzen.

## Die Funktion `data.frame()`

Mit der Funktion `data.frame()` können wir "händisch" einen `data.frame` 
erstellen.[^excel] Die folgende unscheinbare Tabelle wird uns durch 
einen Großteil des Kapitels begleiten, um Grundlagen von 
`data.frame`-Operationen zu betrachten.

[^excel]: In der Praxis werden wir selten händisch einen ganzen 
`data.frame` aufschreiben, sondern stattdessen Daten aus einer externen 
Datei einlesen. Beispielsweise können die Daten in einem 
*Spreadsheet-Editor* wie Excel eingegeben worden sein und wir 
importieren diese dann in `R`.

```{r}
mdf <- data.frame(
  Fallnummer = 1:5,
  Item1 = c(1, 0, 0, 1, 1),
  Item2 = c(1, 1, 0, 0, 1),
  Alter = c(13, 14, 13, 12, 15),
  Geschlecht = c("w", "m", "m", "w", "m")
)
```

Der erstellte `data.frame` ist nun in der Variablen `mdf` -- was 
beispielsweise für "mein `data.frame`" stehen könnte -- abgespeichert.
Durch Eingabe des Variablennamens in der `R`-Konsole können wir die 
ganze Tabelle ausgeben lassen: 

```{r}
mdf
```

Bei der Erstellung des `data.frames` mit der Funktion `data.frame()` 
wurde jede Spalte mit der Funktion `c()` oder dem Doppelpunktoperator 
mit genau einem Vektor befüllt. Alle Spalten wurden bei der Erstellung 
benannt. **Dieser Punkt ist sehr wichtig, da wir Spalten anhand ihrer 
Namen gezielt auswählen können**. Wenn ich die Spaltennamen eines 
`data.frames` nicht mehr weiß, kann ich sie mit der Funktion `names()` 
abrufen:

```{r}
names(mdf)
```

## Zugriff auf eine einzelne Spalte: die `$`-Notation

Der `$`-Zugriff ist die grundlegendste Operation auf `data.frames`. Wir
nutzen ihn, um auf einzelne Spalten zuzugreifen und diese **als Vektor** 
auszulesen:

```{r}
mdf$Item1 # gibt einen Vektor aus
```

Ich kann den `$`-Zugriff nicht nur verwenden, um eine Spalte aus einem 
`data.frame` auszulesen, sondern kann damit auch neue Spalten 
hinzufügen. Das funktioniert, indem ich der neu zu erstellenden Spalte 
per "`<-`" einen Vektor zuweise:

```{r}
## Beachtet die Länge des Vektors
mdf$Augenfarbe <- c("braun", "blau", "blau", "braun", "gruen")
```

Die Tabelle `mdf`[^technischkorrekt] hat nun eine zusätzliche Spalte: 

[^technischkorrekt]: Technisch korrekt müsste ich sagen: Der 
`data.frame`, der in der Variablen `mdf` abgespeichert ist, hat nun eine 
zusätzliche Spalte.

```{r}
mdf
```

Beim Anhängen von Spalten an `data.frames` mit der `$`-Notation kann ich 
jegliche Berechnungsvorschriften für Vektoren verwenden. So kann ich 
etwa einen Testscore über zwei Items berechnen und direkt an den 
`data.frame` anhängen:

```{r}

mdf$Testscore <- mdf$Item1 + mdf$Item2

mdf$Testscore

```

In diesem Beispiel kommt die `$`-Notation recht häufig zum Einsatz, was
etwas gewöhnungsbedürftig aussieht. Aber es ist wichtig darauf zu
achten. Die Variablen,[^doppeldeutig] die wir verwenden, um den
Testscore zu berechnen, "wohnen" in `mdf` und können nicht ohne Verweis
darauf adressiert werden. Das hier geht schief:

[^doppeldeutig]: Es ist etwas unglücklich, dass der Begriff "Variable"
doppeldeutig ist: (1) In `R` sind Variablen die Speicherorte von
Objekten; ich erstelle sie mit der "`<-`"-Zuweisung.  (2) Andererseits
werden auch Messwerte -- etwa die Punktzahlen in einem Testitem -- als
Variablen bezeichnet. In diesem Sinne würde der Begriff Variable in `R`
auf die Spalte in einem `data.frame` verweisen, da Spalten Messvariablen
beinhalten. Diese Doppeldeutigkeit ist deswegen unglücklich, da eine
Spalte in einem `data.frame` keine `R`-Variable ist. Stattdessen ist der
gesamte `data.frame` in **einer** Variablen abgespeichert.

```R
mdf$Testscore <- Item1 + Item2
Fehler: Objekt 'Item1' nicht gefunden
```

Hier sucht `R` nach einer Variablen `Item1`, die aber nicht existiert;
`Item1` ist nur eine Spalte von `mdf`. Noch schlimmer wäre es, wenn in
meiner Arbeitsumgebung tatsächlich Variablen mit den Namen `Item1` und
`Item2` existieren sollten. In dem Fall würden wir gegebenenfalls
falsche Daten abspeichern und nicht einmal eine Fehlermeldung erhalten.

Mit der `$`-Notation werden wir häufig auf Daten zugreifen, um
Berechnungen durchzuführen. Wir können beispielsweise Mittelwerte von
Messvariablen berechnen oder uns Häufigkeiten von kategorialen Daten
angeben lassen:

```{r}
mean(mdf$Alter)
table(mdf$Geschlecht)
```

Die Funktion `mean()` kennen wir bereits. Die Funktion `table()` gibt 
aus, wie häufig jeder Wert in einem Vektor vorkommen. Wir nutzen 
`table()` vor allem zur Beschreibung kategorialer Messvariablen. Auch 
zur Überprüfung der Plausibilität von Daten ist `table()` nützlich: Ist 
jeder Wert ein "legaler" Wert, der auch vorkommen sollte? Wir können die 
Funktion `table()` auch verwenden, um die Häufigkeit der Kombination von 
mehreren Variablen zu erfragen:

```{r}
# Erstelle Kreuztabelle von Geschlecht und Augenfarbe:
table(mdf$Geschlecht, mdf$Augenfarbe)
```

## Zugriff auf Spalten und Zeilen: die `[·,·]`-Notation {#datenzugriffe}

Einzelne Spalten können wir mit dem `$`-Zugriff aus `data.frames`
auslesen. Wir lernen nun den `[·,·]`-Zugriff kennen, mit dem wir nicht
nur einzelne Spalten, sondern beliebige Spalten und Zeilen aus
`data.frames` auslesen können. Wie wir sehen werden, ist der
`[·,·]`-Zugriff dem `[·]`-Zugriff ähnlich, den wir zur Auswahl von Daten
aus Vektoren kennengelernt haben.

Der `[·,·]`-Zugriff erlaubt es uns, eine Teilmenge aller Fälle aus
`mdf` auszuwählen, etwa nur die Personen mit blauen Augen, oder alle
Personen, die den maximalen Testwert erreicht haben. Für solche
Auswahlen hilft uns unser Wissen über [logische Vergleiche aus dem
letzten Kapitel](#logischevergleiche). Betrachten wir zunächst ein
Beispiel:

```{r}
mdf[mdf$Augenfarbe == "blau", ]
```

Beachtet, dass durch diesen Aufruf der `data.frame`, der in der
Variablen `mdf` abgespeichert ist, nicht verändert wird. Der
`[·,·]`-Zugriff gibt stattdessen einen neuen `data.frame` zurück, der
nur die Fälle enthält, bei denen `mdf$Augenfarbe == "blau"` `TRUE`
ergibt. Wir müssten das Ergebnis der Funktion in einer Variablen
speichern, wenn wir damit weiter arbeiten wollen (Erinnerung: [Kapitel
2](#ausgabevsabspeichern)).

Wie das folgende Beispiel zeigt, können wir mit der `[·,·]`-Notation
auch gezielt Spalten aus `data.frames` auswählen:

```{r}
mdf[, c("Augenfarbe", "Alter")]
```

Die zwei Beispiele zeigen, dass das Komma in der `[·,·]`-Notation dafür
entscheidend ist, ob eine Auswahl nach Zeilen oder Spalten stattfindet.
**Vor dem Komma werden Zeilen adressiert, nach dem Komma Spalten.** Es
ist auch eine gleichzeitige Auswahl nach Zeilen **und** Spalten möglich.
Allgemein ist die Syntax zum Ansprechen von `data.frames` mit dem
`[·,·]`-Zugriff die folgende:

```
data.frame[Reihenvektor, Spaltenvektor]
```

Dabei ist *Reihenvektor*/*Spaltenvektor* entweder ein (a) numerischer
Vektor, der die Indexe der Reihen/Spalten enthält, die ausgewählt werden
sollen, (b) ein logischer Vektor, der für jede Reihe/Spalte kodiert, ob
diese in der Ausgabe enthalten sein soll (vgl. Kapitel
[2](#logischerZugriff)), oder (c) Vektor vom Typ `character`, der die
Namen der Zeilen/Spalten enthält, die ausgegeben werden sollen.
[^zeilennamen]

[^zeilennamen]: Auch Zeilen können benannt sein. Den Fall hatten wir
bislang aber nicht und es kommt auch nicht oft vor, dass Zeilen explizit
benannt sind. Häufiger ist der Fall, in dem wir Spalten nach Namen
auswählen.

Spalten werden am häufigsten per Namen -- also durch Angabe eines einen
Vektors vom Typ `character` -- adressiert; Zeilen werden am häufigsten
durch einen logischen Ausdruck -- also durch Angabe eines einen Vektors
vom Typ `logical` -- adressiert ("Gib mir alle Fälle aus, die eine
bestimmte Eigenschaft aufweisen."). Durch die UND- bzw. ODER-Operationen
können wir auch komplexere logische Bedingungen zur Auswahl von Fällen
formulieren:

```{r}
mdf[mdf$Augenfarbe == "blau" | mdf$Augenfarbe == "braun", ]
mdf[(mdf$Augenfarbe == "blau" | mdf$Augenfarbe == "braun") & mdf$Item1 == 1, ]
```

Beachtet, dass wir hier ohne Klammerung der ODER-Operation eine andere
Ausgabe erhalten (Erinnerung: Diesen Fall kennen wir auch aus [Kapitel
2](#praezedenz)):

```{r}
mdf[mdf$Augenfarbe == "blau" | mdf$Augenfarbe == "braun" & mdf$Item1 == 1, ]
```

Wie wir merken, wird die `[·,·]`-Notation recht schnell
unübersichtlich, wenn sie komplexere logische Anfragen enthält. Die
Verknüpfung mehrerer ODER-Bedingungen lässt sich durch den
`%in%`-Operator verkürzen:

```{r}
mdf[mdf$Augenfarbe %in% c("blau", "braun"), ]
```

Im nächsten Abschnitt lernen wir mit der Funktion `subset` eine
Möglichkeit kennen, komplexere logische Anfragen noch etwas prägnanter
zu formulieren. Zum Abschluss dieses Abschnitts betrachten wir noch
einige weitere Beispiele für die verschiedenen Auswahlmöglichkeiten per
`[·,·]`:

```{r}
## Wähle per Index die ersten drei Zeilen aus
mdf[1:3, ]

## Wähle per Index die zweite und vierte Spalte aus
mdf[, c(2, 4)]

## Wähle per logischem Vektor alle Personen aus, die beide Aufgaben
## richtig gelöst haben:
mdf[mdf$Testscore == 2, ]

## Wähle Fallnummer, Alter und Testscore per Spaltenname aus:
mdf[, c("Fallnummer", "Alter", "Testscore")]

## Wähle Fallnummer, Alter und Testscore aus für alle Personen, die
## älter als 13 sind
mdf[mdf$Alter > 13, c("Fallnummer", "Alter", "Testscore")]

## Wähle Fallnummer, Alter und Testscore aus für die ersten drei Fälle
mdf[1:3, c("Fallnummer", "Alter", "Testscore")]

## Wähle die Itemscores aus - nutze dabei die Funktion paste0
mdf[, paste0("Item", 1:2)]

```

```{block, type = "block"}
**Merke**: Mit dem `[·,·]`-Zugriff wird vor dem Komma die
Zeile und nach dem Komma die Spalte adressiert. Man kann die
Auswahl nach numerischem Index, mit einem logischen Vektor oder mit
einem `character` Vektor durchführen.
```

## Die Funktion `subset()` {#subset}

In diesem Abschnitt lernen wir die Funktion `subset()` kennen, die wir 
ebenfalls verwenden können, um Zeilen und Spalten aus `data.frames` 
auszulesen. Ganz ähnlich zur `[·,·]`-Notation funktioniert etwa der 
folgende Aufruf:

```{r}
subset(mdf, mdf$Augenfarbe == "blau", c("Item1", "Augenfarbe"))
```

Als erstes Argument nimmt die Funktion `subset()` immer den `data.frame` 
an, aus dem wir Daten auslesen wollen. Danach folgen Argumente zur 
Auswahl von Zeilen und zur Auswahl von Spalten.

Wie hier angewendet, ist durch die Funktion `subset()` im Vergleich zur 
`[·,·]`-Notation noch nicht viel gewonnen. Was die Funktion `subset()` 
so nützlich macht, ist dass sie zwei wichtige Zugriffe auf `data.frames` 
vereinfacht:

1. [Die Auswahl von Zeilen mithilfe logischer Bedingungen](#zeileneinfach)
2. [Die Auswahl von Spalten durch Angabe von Spaltennamen](#spalteneinfach)

Diese Vereinfachungen besprechen wir im Folgenden. Des Weiteren bietet 
dieser Abschnitt einen ersten theoretischen Überblick über die 
[Arbeitsweise von Funktionen in `R`](#teaserfunktionen), der in [Kapitel 
6](#funktionen) vertieft wird.

### Vereinfachte Zeilenauswahl {#zeileneinfach}

Die Funktion `subset()` erlaubt uns logische Bedingungen für die
Zeilenauswahl zu formulieren, ohne die `$`-Notation zu verwenden:

```{r}
subset(mdf, Augenfarbe == "blau")
```

Folgendermaßen könnte man durch Verwendung von `$` einen äquivalenten 
Aufruf durchführen, der uns eher an die `[·,·]`-Notation erinnert:

```{r}
subset(mdf, mdf$Augenfarbe == "blau")
```

Außerhalb der Funktion `subset()` würde der Ausdruck `Augenfarbe == 
"blau"` einen Fehler ausgeben; schließlich ist `Augenfarbe` selbst keine 
`R`-Variable, sondern nur eine Spalte von `mdf`.[^innehalten] Innerhalb 
der Funktion `subset()` kann die logische Bedingung in dieser Form jedoch 
verarbeitet werden.

[^innehalten]: Es macht an dieser Stelle Sinn, einen Moment inne zu
halten und zu überlegen, warum es eigentlich außergewöhnlich ist, dass
der Befehl `Augenfarbe == "blau"` innerhalb der Funktion `subset`
funktioniert.

Der äquivalente Befehl mit der `[·,·]`-Notation sähe folgendermaßen aus:

```R
mdf[mdf$Augenfarbe == "blau", ]
```

Gerade bei der Verknüpfung mehrerer logischer Bedingungen ist es
praktisch, nicht mehrfach die `$`-Notation verwenden zu müssen:

```{r}
subset(mdf, Augenfarbe == "blau" & Item2 == 1)
```

### Funktionsargumente {#teaserfunktionen}

Die Funktion `subset()` nimmt optional ein drittes Argument an, das
auszulesende Spalten adressiert:

```{r}
subset(mdf, Augenfarbe == "blau", c("Item1", "Augenfarbe"))
```

Durch die Kombination der Auswahl von Zeilen und Spalten gibt dieser
Befehl einen `data.frame` aus, der nur die Spalten `Item1` und
`Augenfarbe` enthält, und diese nur für Personen mit blauen Augen.

Was machen wir aber, wenn wir nur eine Auswahl nach Spalten durchführen
wollen? Probieren wir erst einmal Folgendes:

```R
subset(mdf, c("Item1", "Augenfarbe"))
```

Hier habe ich einfach das Argument für die Zeilenauswahl weggelassen und
als zweites Argument einen `character`-Vektor zur Auswahl zweier Spalten
angegeben -- was aber nicht funktioniert hat. `R` gibt uns eine
kryptische Fehlermeldung aus:

```R
Fehler in subset.data.frame(mdf, c("Item1", "Augenfarbe")) : 
  'subset' muss boolesch sein
```

Warum gibt uns `R` hier einen Fehler aus? An dieser Stellen machen wir 
uns eine wichtige Eigenschaft von Funktionen bewusst: **Funktionen 
identifizieren Argumente anhand der Reihenfolge, in der sie übergeben 
werden.** Bei der Funktion `subset()` ist das erste Argument der 
`data.frame`, von dem wir Daten anfordern. Das zweite Argument wählt mit 
einem logischen Ausdruck Zeilen aus. Das dritte Argument adressiert 
Spalten.

Wir erhalten den obigen Fehler also, weil die Funktion `subset()` an
zweiter Stelle einen logischer Ausdruck zur Zeilenauswahl erwartet; die
Auswahl der Spalten muss mit dem dritten Argument geschehen. Um eine
Auswahl trotzdem nur nach Spalten auszuführen, können wir eine
praktische Eigenschaft von `R` ausnutzen: **Funktionsargumente haben
Namen.** Anstatt Argumente anhand ihrer Position zu identifizieren,
können wir sie auch benennen. Bislang haben wir das ignoriert bzw. es
ist uns nur am Rande begegnet -- erinnern wir uns an das Argument
`na.rm` der Funktion `mean()`.

Die Funktion `subset()` hat drei benannte Argumente:

- `x`: der Datensatz, aus dem ausgewählt wird
- `subset`: wählt Zeilen aus
- `select`: wählt Spalten aus

Um eine Übersicht über die Argumente einer Funktion zu erhalten, können
wir mit dem `?`-Operator die `R`-Hilfe anfordern:

```R
?subset
```

Leider ist die `R`-Hilfe oftmals kryptisch -- und das nicht nur für
Anfänger. Sie ist die offizielle Dokumentation von Funktionen und legt
deswegen zwar großen Wert auf technische Genauigkeit, ist aber nicht
immer sonderlich ausführlich oder gar verständlich. Wir werden in
[Kapitel 5](#funktionen) bei einer ausführlicheren Besprechung von
Funktionen noch einmal darauf zurückkommen, wie wir mit der
`R`-Hilfe umgehen können.

Wenn wir die Namen der Argumente kennen, können wir die Funktion
`subset()` auch wie folgt aufrufen:

```{r}
subset(
  x = mdf, 
  subset = Augenfarbe == "blau",
  select = c("Item1", "Augenfarbe")
)
```

Beachtet, dass ich beim Funktionsaufruf Zeilenumbrüche zwischen den 
Argumenten nutze, was nicht hätte sein müssen -- das mache ich nur, 
damit mein Code schön übersichtlich ist. 

Wenn ich Funktionsargumente mit Namen adressiere, kann ich deren 
Reihenfolge beliebig vertauschen. Deswegen funktioniert auch der 
folgende Aufruf:

```{r}
subset(
  select = c("Item1", "Augenfarbe"),
  subset = Augenfarbe == "blau", 
  x = mdf
)
```

Eine Auswahl nur anhand von Spalten können wir umsetzen, indem wir 
benannt nur das Argument `select` angeben, aber nicht das Argument 
`subset`:

```{r}
subset(mdf, select = c("Item1", "Augenfarbe"))
```

Dieser Aufruf zeigt, dass wir im selben Aufruf manche Argumente anhand
ihrer Position identifizieren können und manche anhand ihres Namens. Für
das erste Argument `mdf` habe ich den Namen nicht extra angegeben
-- daher wurde das Argument anhand seiner Position identifiziert. Für
die Auswahl der Spalten habe ich jedoch den Argumentnamen angegeben.
**Das war auch nötig**, da `subset()` als zweites Argument ansonsten die
Auswahl der Zeilen erwartet hätte.

```{block, type = "block"}
**Merke**: In `R` können Funktionsargumente per Position und per Namen
identifiziert werden. Die Identifikation per Name schlägt dabei die
Identifikation per Position. Argumente explizit mit ihrem Namen zu
benennen ist oft sicherer als auf die richtige Reihenfolge der Argumente
zu vertrauen.
```

### Sonderregeln zur Auswahl von Spalten {#spalteneinfach}

Die Funktion `subset()` bietet einige Sonderregeln zur Auswahl von
Spalten, die über die Angabe der Spaltennamen per `character`-Vektor
hinausgehen, wie wir sie von der `[·,·]`-Notation kennen. Zunächst
einmal können wir Spaltennamen ohne Anführungszeichen angeben:

```{r}
subset(mdf, select = c(Augenfarbe, Alter))
```

Genau wie die Zeilenauswahl, die ohne die `$`-Notation auskommt, ist es
eine Besonderheit der Funktion `subset()`, dass wir Spaltennamen ohne
Anführungszeichen adressieren können. Einfach in die Konsole eingegeben
würde der Ausdruck `c(Augenfarbe, Alter)`
höchstwahrscheinlich[^wannnicht] einen Fehler verursachen, da
`Augenfarbe` und `Alter` nicht unbedingt als Variablen definiert sind;
sie sind bloß Spalten von `mdf`.

[^wannnicht]: Unter welchen Umständen würde `R` keinen Fehler
ausgeben, wenn wir `c(Augenfarbe, Alter)` in die Konsole eingeben? Es
ist nützlich, diesen Punkt zu verstehen.

Die Auswahl von Spalten ohne Anführungszeichen ist noch keine allzu
große Arbeitserleichterung im Vergleich zur `[·,·]`-Notation. Die
Funktion `subset` lässt aber noch einen weiteren Sonderfall bei der
Spaltenauswahl zu, der einiges an Schreibarbeit ersparen kann: Wir
können den Doppelpunktoperator verwenden, um mehrere Spalten
auszuwählen.

```{r}
subset(mdf, select = Item1:Geschlecht)
```

Von „links nach rechts“ wählt der Doppelpunktperator alle Spalten
zwischen einschließlich `Item1` und `Geschlecht` aus. Auch hier
verzichten wir auf die Angabe von Anführungszeichen.

Es gibt noch eine weitere Vereinfachung, die uns die Funktion `subset`
bietet. Wir können angeben, welche Spalten wir **nicht** ausgeben
wollen:

```{r}
subset(mdf, select = -c(Geschlecht, Alter))
```

### Umgang mit `NA`: `subset()` bevorzugt zur Zeilenauswahl

Außer, dass uns `subset()` syntaktische Vereinfachungen zur Auswahl von Zeilen 
und Spalten bietet, ist auch das Verhalten von `subset()` manchmal gegenüber dem 
`[·,·]`-Zugriff zu bevorzugen -- zumindest was die Auswahl von Zeilen angeht. 
Betrachten wir im Folgenden, wie `subset()` und der `[·,·]`-Zugriff jeweils auf 
die Anwesenheit von fehlenden Werten (`NA`) reagieren:

```{r}
minidf <- data.frame(
  nummer = 1:5,
  wert = c(1, 2, 4, NA, 1)
)
```

```{r}
minidf[minidf$wert < 4, ]
```

Die Ausgabe des `[·,·]`-Zugriffs sieht etwas unschön aus; für die Zeile, in der 
`minidf$wert` den Wert `NA` hat, wird hier eine Zeile ausgegeben, die nur aus 
fehlenden Werten besteht (selbst die Zeilennummer wird auf `NA` gesetzt!). Es 
ist schwierig vorstellbar, dass diese Ausgabe wünschenswert sein mag; zumindest 
erinnert sie an das Vorhandensein fehlender Werte. Die Funktion `subset()` 
hingegen schließt die Zeile aus, in der `minidf$wert` fehlt: 

```{r}
subset(minidf, wert < 4)
```

Diese Ausgabe entspricht vermutlich häufiger dem gewünschten Verhalten. Um diese 
Ausgabe auch mit der `[·,·]`-Notation zu erhalten, ist folgender, umständlicher
Befehl nötig:

```{r}
minidf[minidf$wert < 4 & !is.na(minidf$wert), ]
```

In interaktiven Datenauswertungen würde ich oftmals die Nutzung der Funktion 
`subset()` empfehlen, wobei gerade bei der Spaltenauswahl die `[·,·]`-Notation 
ihre Stärken hat, etwa was die automatisierte Generierung von Spaltennamen als 
`character`-Vektor angeht. Glücklicherweise können wir beide Notationen gemischt 
anwenden, um die jeweiligen Stärken auszunutzen.

## Weitere Zugriffe auf `data.frames` {#doppelteckig}

Dieser Abschnitt behandelt zwei weitere Möglichkeiten, mit eckigen
Klammern auf Spalten in `data.frames` zuzugreifen. Da wir diese Zugriffe
danach erst einmal nicht weiter verwenden, kann der folgende Inhalt jedoch
zunächst problemlos [übersprungen werden](#convenient). Datenzugriffe
mit eckigen Klammern sind jedoch ein zentraler Bestandteil von `R`;
daher lohnt es sich, diesen Abschnitt später zu konsultieren oder zum
Nachschlagen zu nutzen.

### Der `[[·]]`-Zugriff

Den `[[·]]`-Zugriff nutzen wir genau wie den `$`-Zugriff zum Auslesen
einzelner Spalten aus `data.frames`:

```{r}
mdf[["Item1"]] # dasselbe wie mdf$Item1
```

Hierbei wird der Spaltenname als ein-elementiger Vektor vom Typ
`character` angegeben -- also in Anführungszeichen. Die
Anführungszeichen sind hier notwendig, bei der `$`-Notation verwenden
wir sie hingegen nicht. Das hat zur Folge, dass wir statt der expliziten
Angabe des Texts auch eine Variable übergeben können, die einen
ein-elementigen `character`-Vektor abgespeichert hat; dies ist mit der
`$`-Notation nicht möglich.

```{r}
spalte <- "Augenfarbe"
mdf[[spalte]]
```

Ebenso ist es möglich, der `[[·]]`-Klammerung eine Funktion zu
übergeben, die einen ein-elementigen Vektor vom Typ character ausgibt
-- etwa die Funktion `paste0()`:

```{r}
mdf[[paste0("Item", 1)]]
```

Der `[[·]]`-Zugriff wird in Zusammenspiel mit der Funktion `paste0()` 
noch einmal interessant werden, wenn wir in [Kapitel 6](#schleifen) mit 
*Schleifen* nacheinander auf beliebig viele Spalten von `data.frames` 
zugreifen. In einer Schleife können wir dann Spaltennamen automatisiert 
nacheinander austauschen (etwa: `Item_1`, `Item_2`, ...).

### Der `[·]`-Zugriff

**Nicht** äquivalent zu den Zugriffen mit `$` und `[[·]]` ist
folgender `[·]`-Zugriff:

```{r}
mdf["Item1"]
```

Auch hier sind Anführungszeichen zur Identifikation der auszuwählenden
Spalte nötig. Der Unterschied von `[·]` zu `[[·]]` und `$`:

- `[[·]]` und `$` ergeben einen Vektor
- `[·]` ergibt einen `data.frame` mit einer Spalte

Außerdem können wir mit dem `[·]`-Zugriff gleichzeitig mehrere Spalten
auswählen, indem wir einen mehr-elementigen Vektor vom Typ `character`
übergeben. Das ist mit den Zugriffen per `[[·]]` und `$` nicht möglich,
die immer nur eine Spalte ausgeben.

```{r}
mdf[c("Item1", "Augenfarbe")]
```

Dieser Aufruf sollte uns an die `[·,·]`-Notation zur Auswahl von Spalten
erinnern; in der Tat ist der folgende Ausdruck äquivalent:

```{r}
mdf[, c("Item1", "Augenfarbe")]
```

Zwischen dem `[·]`-Zugriff und der `[·,·]`-Auswahl für Spalten gibt es
jedoch einen Unterschied, der zutage kommt, wenn wir nur eine Spalte
auswählen:

```{r}
mdf["Item1"]
```

```{r}
mdf[, "Item1"]
```

Wenn wir nur eine Spalte auslesen, gibt die `[·,·]`-Auswahl einen Vektor
aus, die `[·]`-Auswahl jedoch einen `data.frame` mit einer Spalte.
Dieses Verhalten offenbart einen Sonderfall der `[·,·]`-Auswahl: Im
Normalfall gibt `[·,·]` ebenfalls einen ganzen `data.frame` aus. Wenn
wir aber nur eine einzige Spalte anfordern, „reduziert“ sich die Ausgabe
zu einem Vektor.

Ich persönlich bevorzuge die `[·,·]`-Notation gegenüber der
`[·]`-Notation zur Auswahl von Spalten, auch wenn ich hier ein
zusätzliches Komma verwenden muss (ansonsten sind die beiden Notationen
ja fast äquivalent zur Auswahl von Spalten). Wenn ich Code mit der
`[·,·]`-Notation lese, weiß ich, dass Spalten ausgewählt werden --
selbst wenn ich gar nicht weiß, was in dem Objekt steckt, auf dem die
Auswahl stattfindet. Die `[·]`-Notation ist uneindeutiger: Sie könnte
auch auf einem Vektor operieren, der gar keine Spalten enthält. Wir
merken uns: **Code ist in erster Linie für Menschen gemacht;
verständlicher Code ist gegenüber kürzerem Code zu bevorzugen.**

### Zugriff nach Name und Index {#nameindex}

Wir haben nun alle wichtigen Möglichkeiten kennengelernt, Zugriffe auf
`data.frames` durchzuführen. An dieser Stelle lohnt es sich deswegen,
ein grundsätzliches Prinzip von Datenzugriffen in `R` festzuhalten:
**Datenzugriffe können nach nach Index oder nach Name stattfinden**.
Dies gilt für Vektoren, `data.frames` und auch für andere
Datenstrukturen, die wir noch gar nicht behandelt haben.

Wir haben bereits Beispiele für beide Arten des Datenzugriffs
kennengelernt: In Vektoren haben wir Zugriffe mithilfe von Indexen
durchgeführt, indem wir (a) die Position von auszuwählenden Elementen
mit einem numerischen Vektor angegeben haben, oder (b) indem wir einen
logischen Vektor übergeben haben, der die Indexe auswählt, deren
Elemente ausgegeben werden sollen. Der Vollständigkeit halber sei hier
mitgeteilt, dass man sogar bei Vektoren Zugriffe nach Namen durchführen
kann, wenn die Elemente des Vektors benannt sind. Das ist gar nicht so
ungewöhnlich; wie folgt könnte man einen Vektor mit benannten Elementen
erstellen und mit der bekannten `[·]`-Notation darauf zugreifen.

```{r}

## Benannte Vektoren erstellen funktioniert wie einen data.frame zu
## erstellen:
vec <- c(foo = 1, bar = 2)
vec

vec["foo"]
vec["bar"]
vec[c("bar", "foo")]

```

In `data.frames` haben wir Spalten zumeist nach Namen ausgewählt:

- Mit der `$`-Notation
- Mit der `[·,·]`-Notation
- Mit der Funktion `subset()`
- Mit der `[[·]]`-Notation
- Mit der `[·]`-Notation

Wie wir gesehen haben, können wir mit der `[·,·]`-Notation in
`data.frames` zusätzlich auch Zugriffe nach numerischem oder logischem
Index durchführen. Dabei kann die Auswahl sowohl nach Spalten als auch
nach Zeilen -- oder beidem -- geschehen.

## Nützliche Funktionen zum Arbeiten mit `data.frames` {#convenient}

### Gruppierte Statistiken: `tapply()` {#tapply}

Die Funktion `tapply()` kann ich verwenden, um mir deskriptive
Statistiken anhand von Gruppierungsvariablen ausgeben zu lassen, hier
etwa die mittlere Punktzahl oder das mittlere Alter nach Geschlecht der
Schüler/innen:

```{r}
tapply(mdf$Testscore, mdf$Geschlecht, mean)
tapply(mdf$Alter, mdf$Geschlecht, mean)
```

Die Funktion `tapply()` erhält als erstes Argument den Messwertvektor, für
den Statistiken angefordert werden. Das zweite Argument ist die 
Gruppierungsvariable.[^warumhier] Interessanterweise ist das dritte 
Argument eine Funktion, in diesem Fall die Funktion `mean()`. So können 
wir die *mittlere* Punktzahl nach Geschlecht anfordern. Entsprechend 
könnten wir hier andere Funktionen übergeben, um etwa die 
Standardabweichung des Alters zu erfragen:

[^warumhier]: Beachtet, dass sowohl Messwerte als auch 
Gruppierungsvariable als **Vektoren** übergeben werden. Ich behandle die 
Funktion `tapply()` jedoch im Kapitel zu `data.frames`, da es zumeist so 
sein wird, dass wir beide Vektoren aus **einem** `data.frame` mit der 
`$`-Notation auslesen werden.

```{r}
tapply(mdf$Alter, mdf$Geschlecht, sd)
```

Wie `table()` kann auch `tapply()` deskriptive Statistiken anhand 
mehrerer Gruppierungsvariablen anfordern. Um mehrere 
Gruppierungsvariablen anzufordern, klammern wir `list(...)` um die 
Gruppierungsvektoren im zweiten Argument:

```{r}
tapply(mdf$Alter, list(mdf$Geschlecht, mdf$Augenfarbe), mean)
```

Mit nur fünf Datenpunkten macht diese Anfrage hier nur wenig Sinn, da 
jeder ausgegebene Mittelwert nur anhand eines einzelnen Wertes gebildet 
wurde,[^nochmaltable] was die Idee des Mittelwerts eher ad absurdum 
führt. Manche Kombinationen von Geschlecht und Augenfarbe kommen in 
unseren Daten sogar gar nicht vor; in diesen Fällen wird `NA` 
ausgegeben. Die Funktion `tapply()` zeigt ihre Stärke vor allem, wenn 
man viele -- und nicht nur fünf -- Datenpunkte hat. Das gilt gerade 
dann, wenn wir mehrere Gruppierungsvariablen angeben.

[^nochmaltable]: Wie viele Datenpunkte in die Berechnung jedes
Mittelwerts eingehen, können wir in diesem Fall prüfen mit
`table(mdf$Geschlecht, mdf$Augenfarbe)`.

### Datenstruktur: `nrow()` und `ncol()`

Wie viele Zeilen ein `data.frame` hat -- d.h. oftmals die Zahl der
*Fälle* -- lässt sich mit der Funktion `nrow()` bestimmen:

```{r}
nrow(mdf)
```

Analog gibt `ncol()` die Zahl der Spalten aus:

```{r}
ncol(mdf)
```

### Wie sieht die Tabelle aus: `head()` und `tail()`

Um sich einen Überblick über einen `data.frame` zu verschaffen, sind die 
Funktionen `head()` und `tail()` sehr nützlich. Die Funktion `head()` 
gibt die ersten Zeilen eines `data.frames` aus; `tail()` gibt 
entsprechend die letzten Zeilen aus. Beide Funktionen haben ein zweites 
Argument `n`, mit dem wir spezifizieren können, wie viele Zeilen 
ausgegeben werden sollen. Wenn wir `n` nicht angeben, werden sechs 
Zeilen ausgegeben (in `R`-Jargon: 6 ist der Standardwert des *optionalen 
Arguments* `n`). Wir können die Funktionen wie folgt nutzen:

```{r}
head(mdf, n = 2)
tail(mdf, n = 3)
```

### Sortieren: Die Funktion `arrange`() aus dem Paket `dplyr`

Oftmals wollen wir Datentabellen nach einer oder mehreren Variablen
sortieren. Dies funktioniert am bequemsten, wenn wir das *Paket* `dplyr`
laden [@R-dplyr]:

```{r}
library("dplyr")
```

Voraussetzung dafür, dass ich das Paket `dplyr` nutzen kann ist, dass
ich das Paket auf meinem Rechner installiert habe. Falls das Paket noch
nicht installiert ist -- in dem Fall ergibt der Befehl
`library('dyplr')` einen Fehler -- können wir es es mit dem folgenden
Befehl installieren:

```R
install.packages("dplyr")
```

Pakete stellen zusätzliche Funktionen zur Verfügung, die in der 
Basisversion von `R` nicht enthalten sind. Um ein Paket zu nutzen, 
müssen wir es mit der Funktion `library()` in unsere `R`-Umgebung laden. 
Andernfalls könnten wir die Funktionen nicht nutzen, die etwa `dplyr` 
enthält. Die Funktion `arrange()` aus `dplyr` ermöglicht es uns, einen 
`data.frame` zu sortieren:

```{r}
arrange(mdf, Testscore) # dplyr muss geladen sein
```

In der Funktion `arrange()` geben wir als erstes Argument den zu
sortierenden `data.frame` an. Darauf folgen -- mit Komma separiert --
alle Spalten nach denen wir sortieren wollen (hier erst mal nur der
Testscore). Standardmäßig sortiert `arrange()` *aufsteigend*; wenn wir
eine absteigende Sortierung wünschen, müssen wir ein Minus vor die
Sortierspalte setzen:

```{r}
arrange(mdf, -Testscore)
```

Es ist auch möglich, nach mehreren Spalten zu sortieren. In dem Fall
wird bei gleichen Werten im ersten Sortierkriterium anhand des nächsten
Kriteriums die Reihenfolge entschieden. Wir könnten etwa unsere Daten
nach Geschlecht sortieren, und innerhalb der Personen gleichen
Geschlechts nach Punktzahl:

```{r}
arrange(mdf, Geschlecht, -Testscore)
```


### Zusammenfassung aller Spalten: Hilfe aus externen Paketen

Es gibt zahlreiche Funktionen, aus verschiedenen `R`-Zusatzpaketen und auch aus 
„Base-`R`“ selbst, die alle dafür gedacht sind, möglichst kompakt einen 
Überblick über einen ganzen `data.frame` zu bieten. Solche Funktionen geben 
normalerweise pro Spalte deskriptive Statistiken aus -- etwa Mittelwert, 
Standardabweichung, Perzentile, Minimum, Maximum, oder eine 
Häufigkeitsverteilung bei kategorialen Faktoren -- und wie viele Werte darin 
fehlen, also `NA` sind. Bei der Arbeit mit einem neuen Datensatz ist es nützlich 
auf diese Weise erst einmal einen groben Überblick zu erhalten.

Zu nennen sind etwa folgende Funktionen: 

- Die Funktion `skim()` aus dem Paket `skimr` [Waring et al., -@R-skimr]
- Die Funktion `describe()` aus dem Paket `psych` [@R-psych]
- Die Funktion `describe()` aus dem Paket `Hmisc` [@R-Hmisc]
- Die Funktion `summary()`, schon ohne Zusatzpaket in `R` enthalten

Probiert ruhig alle genannten Funktionen aus und entscheidet dann, welche euch 
davon am besten gefällt. Diese kann dann regelmäßig zur Explorationen neuer 
Datensätze genutzt werden. Um die Funktionen auszuprobieren, können die nötigen 
Zusatzpakete mit der Funktion `install.packages()` installiert und der Funktion 
`library()` geladen werden:

```{r, eval = FALSE}
# Man kann mit einem Befehl mehrere Pakete installieren:
install.packages(c("skimr", "psych", "Hmisc"))
```

```{r, eval = FALSE}
# Geladen werden müssen sie aber alle einzeln:
library("skimr")
library("psych")
library("Hmisc")
```

Beachtet an dieser Stelle noch einmal, dass Zusatzfunktionen aus Paketen erst 
dann genutzt werden können, wenn diese per `library()` geladen wurden; es reicht 
nicht aus, wenn ein Paket nur per `install.packages()` installiert wurde. 
Insbesondere heißt das, dass benötigte `R`-Zusatzpakete in jeder neuen 
`R`-Sitzung mit `library()` neu geladen werden müssen. Eine (fast) äquivalente 
Alternative zu `library()` stellt die Funktion `require()` dar.

Interessanterweise bemerken wir an dieser Stelle ein mögliches Problem, das sich 
bei der Arbeit mit `R`-Paketen ergeben kann: Sowohl im Paket 
`psych`[^psychwichtig] als auch im Paket `Hmisc` gibt es eine Funktion mit dem 
Namen `describe()`. Wenn ich per `library()` beide Pakete geladen habe -- welche 
Funktion wird dann genutzt, wenn ich `describe()` aufrufe? Das ist von 
vornherein leider nicht zu sagen und hängt von der Reihenfolge ab, in der die 
Pakete geladen wurden. Wenn ich gezielt genau eine der beiden Funktionen 
ansteuern will, kann ich den doppelten Doppelpunktoperator nutzen, um das 
zugehörige Paket anzugeben:

```{r, eval = FALSE}
psych::describe(mdf)
Hmisc::describe(mdf)
```

Die Variante mit doppeltem Doppelpunkt ist in jedem Fall sicher und sollte 
verwendet werden, wenn aus verschiedenen Paketen Funktionen mit demselben Namen 
in Konflikt stehen. Wer ganz sicher gehen will, kann bei der Verwendung von 
Funktionen aus Zusatzpaketen immer den doppelten Doppelpunktoperator nutzen, 
auch wenn das vermutlich ein bisschen übertrieben ist. In der psychometrischen 
Auswertung kann sich beispielsweise der Konflikt ergeben, dass in den zwei 
wichtigen Paketen `psych` [@R-psych] und `psychometric` [@R-psychometric] 
jeweils eine Funktion `alpha()` zur Berechnung von Cronbachs Alpha zur Verfügung 
gestellt wird. Beide berechnen zwar -- wie zu erwarten -- Cronbachs Alpha, 
jedoch gibt `psych::alpha()` noch weitere Ergebnisse aus, wohingegen 
`psychometric::alpha()` wirklich nur Cronbachs Alpha liefert.

[^psychwichtig]: Das Paket `psych` ist in der psychometrischen Arbeit übrigens 
äußerst wichtig; beispielsweise enthält es viel genutzten Funktionen für 
Faktorenanalysen (etwa eine Standardimplementierung der Parallelanalyse), eine 
Funktion, die Cronbachs Alpha berechnet, und viele mehr.

## Zusammenfassung

- Wir haben den `data.frame` als Datenstruktur zur Speicherung von
  psychometrischen Daten kennengelernt
- Wir haben die `$`-Notation für den Zugriff auf einzelne Spalten von 
  `data.frames` kennengelernt
- Mit der `[·,·]`-Notation und der Funktion `subset()` können wir Zeilen 
  und Spalten aus `data.frames` auslesen
- Zur Anforderung von deskriptiven Statistiken können wir die Funktionen
  `table()` und `tapply()` verwenden
- Wir haben weitere Funktionen kennengelernt, die uns einen Überblick
  über `data.frames` verschaffen:
    + `names()`
    + `nrow()/ncol()`
    + `head()/tail()`
    + `dplyr::arrange()`

## Fragen zum vertiefenden Verständnis

1. Worin unterscheiden sich die folgenden Aufrufe? Welche Aufrufe sind
   zueinander äquivalent?

```R
subset(mdf, select = "Item1")
```

```R
mdf[, "Item1"]
```

```R
mdf[, "Item1", drop = FALSE]
```

```R
mdf["Item1"]
```

```R
mdf[["Item1"]]
```

```R
mdf$Item1
```

2. Vergleicht die folgenden Aufrufe der Funktion `subset`. Warum
   funktionieren der erste und der zweite Aufruf, aber nicht der dritte
   und vierte?  Wie kann es überhaupt sein, dass die ersten beiden
   Funktionsaufrufe funktionieren, obwohl Argumente unbenannt an der
   "falschen" Position stehen?

```R
subset(mdf, select = "Item1", Augenfarbe == "blau")
```

```R
subset(select = "Item1", mdf, Augenfarbe == "blau")
```

```R
subset(mdf, "Item1", Augenfarbe == "blau")
```

```R
subset("Item1", mdf, Augenfarbe == "blau")
```
