 
# Eigene Funktion: Bepunktung von Items

In diesem Kapitel stelle ich eine Anwendung unserer bisher erworbenen 
Programmierkenntnisse vor: Wir schreiben eine eigene Funktion, die für beliebige 
Datensätze die Bepunktung von Testitems umsetzt. Dabei kombinieren wir unsere 
erworbenen Kenntnisse aus den letzten beiden Kapiteln zu Funktionen und zu 
Schleifen. Wir gehen vor allem auf die Entscheidungen ein, die beim Schreiben 
einer Funktion getroffen werden müssen, es geht hier weniger um die eher 
technische Programmierseite der Definition von Funktionen. 

Eine Funktion zu schreiben bedeutet, ein gegebene Problem zu abstrahieren, sich 
von der konkreten Problematik (zumeist: dem einzelnen Datensatz), zu entfernen, 
die Essenz des Problems zu begreifen, und eine allgemeines Schema zur Lösung des 
Problems herzustellen. Die Bepunktung von Items bietet sich sehr gut als 
Beispiel für die "Extraktion" einer Funktion an, da das Problem bei beliebigen 
Testinventaren auftreten kann; wir könnten eine generalisierte Funktion in ganz 
vielen unterschiedlichen Datenauswertungen gebrauchen.

## Problemspezifischer Code vs. abstrahierter Code

Betrachten wir noch einmal die Schleifen zur Bepunktung der NPI-Items aus dem 
letzten Kapitel und überlegen, welche Bestandteile des Codes problemspezifisch 
sind; diese müssen in einer Funktion entfernt werden, aber die Funktionalität 
des Codes muss natürlich erhalten bleiben.

```{r}
for (i in 1:40) {
    # 1. Wähle Spaltenname des i-ten Items aus:
    colname <- paste0("Q", i)
    # 2. Wähle aus Spalte die Antworten aus:
    ith_item <- npi_clean[[colname]]
    # 3. Führe Umkodierung durch:
    narcissistic_response <- ifelse(ith_item == keys[i], 1, 0)
    # 4. Erstelle Namen für neue Spalte:
    new_colname  <- paste0("coded", colname)
    # 5. Hänge kodierte Werte an data.frame an:
    npi_clean[[new_colname]] <- narcissistic_response
}
```

Welche Bestandteile dieses Codes sind problemspezifisch?

1. Die Zahl der Schleifendurchläufe ist "hart kodiert" und nicht dynamisch; hier 
wird angenommen, dass die Schleife 40 Mal laufen muss, was daran liegt, dass das 
NPI aus 40 Items besteht und wir deswegen 40 Spalten bearbeiten. In einer 
Funktion sollten wir `ncol()` nutzen, um die Zahl der zu bearbeitenden Spalten 
dynamisch auszulesen.
2. Schritt 1 der Schleife greift auf die Spaltennamen des konkreten `data.frame`s 
zu, der hier bearbeitet wurde. Eine allgemein nutzbare Funktion sollte natürlich 
nicht davon ausgehen, dass die Namen in einem eingegebenen `data.frame` einem 
bestimmten Schema folgen. Die Spaltennamen sollten entweder per `colnames()` 
(bei `data.frames` ist dieser Befehl äquivalent zu `names()`) ausgelesen werden, 
oder wir adressieren die Spalten gleich mit einem [numerischen 
Index](#indexadressierung).

Diese Erkenntnisse sind wichtig, um den problemspezifischen Code in eine 
Funktion umzuwandeln. In einer Funktion wollen wir mit einem beliebigen 
`data.frame` arbeiten können. Dies impliziert, dass wir einer Funktion einen 
`data.frame` übergeben müssen, der nur aus den Spalten der Items besteht, die 
tatsächlich umkodiert werden müssen. Alle anderen Spalten sind für das Problem 
als solches nicht relevant. Im Folgenden Beispiel habe ich den Code 
umgeschrieben und alle problemspezifischen Aspekte entfernt; danach muss der 
Code aber noch in eine Funktion gepackt werden. 

```{r, eval = FALSE}

# Annahmen:
#   * `df` ist ein data frame, der die Items enthält
#   * `keys` ist ein Vektor, der die Schlüssel enthält

n_items <- ncol(df) 

# Folgendes muss TRUE ergeben: `n_items == length(keys)`! Warum?

# Lies die Spaltennamen aus:
item_names <- colnames(df)

for (i in 1:n_items) {
    # Direkte Umkodierung des i'ten Items:
    coded_responses <- ifelse(df[[i]] == keys[i], 1, 0)
    # Hänge umkodierte Werte an den urspünglichen data frame an:
    new_colname <- paste0("coded_", item_names[i])
    df[[new_colname]] <- coded_responses
}

```


Dieser Code ist schon recht nah an der Funktionalität einer Funktion dran; indem 
wir die Variablen `df` und `keys` mit für uns angepassten Werten versehen, 
könnten wir den Code wiederholt aufrufen und damit in verschiedenen 
Datenauswertungen das Problem der Item-Umkodierung lösen. Aber: der nächste 
Schritt, tatsächlich eine Funktion daraus zu bauen, macht den Code noch 
nützlicher. 

In einer Funktion wandeln wir die zwei Variablen aus dem obigen Code in 
Parameter um; sie sind die einzigen Werte, die sich an ein konkretes Problem 
anpassen müssen. Die Funktion, die wir erhalten sieht somit wie folgt aus: 

```{r}
score_items <- function(df, keys) {
    n_items <- ncol(df) 
    item_names <- colnames(df)
    for (i in 1:n_items) {
        coded_responses <- ifelse(df[[i]] == keys[i], 1, 0)
        new_colname <- paste0("coded_", item_names[i])
        df[[new_colname]] <- coded_responses
    }
    # Gib den data frame mit den zusätzlichen Spalten zurück:
    return(df)
}
```

Freunde von kürzerem Code können hier einige Zeilen sparen; etwa die folgende 
Definition der Funktion ist äquivalent: 

```{r}
score_items <- function(df, keys) {
    for (i in 1:ncol(df)) {
        col <- colnames(df)[i]
        df[[paste0("coded_", col)]] <- ifelse(df[[i]] == keys[i], 1, 0)
    }
    df # `return()` hier sogar gar nicht nötig
}
```

Probieren wir unseren Code mit dem NPI-Datensatz aus. Wir nutzen der Übersicht 
halber nur einen sehr kleinen Teil des Datensatzes (4 Personen + 4 Items):

```{r}
items <- npi_clean[1:4, paste0("Q", 1:4)]
items

items_scored <- score_items(items, keys[1:4])
items_scored
```

## Entscheidungen und Varianten

Funktionen zu schreiben bedeutet nicht nur die technische Seite zu beherrschen 
und ein Problem zu abstrahieren -- vielmehr stecken darin weiterhin einige 
subjektive Entscheidungen, die die Nutzung der Funktion betreffen. Es ist kein 
Zufall, wie ich oben die Funktion `score_items()` geschrieben habe, jedoch hätte 
sie auch anders aussehen können. Damit meine ich nicht nur den Code im Körper 
der Funktion, sondern auch deren Verhalten, etwa: welche Parameter nimmt die 
Funktion an, und welchen Wert gibt sie zurück. Exemplarisch zeige ich im 
Folgenden einige Varianten dieser Funktion, die sich im Verhalten unterscheiden, 
obwohl in jedem Fall prinzipiell dasselbe geschieht: eine Funktion kodiert eine 
Sammlung von Testitems um. 

### Version 2: Keine Rückgabe der Ursprungsdaten

```{r}
score_items2 <- function(df, keys) {
  for (i in 1:ncol(df)) {
    df[[i]] <- ifelse(df[[i]] == keys[i], 1, 0)
  }
  df
}
```

Diese Variante der Funktion unterscheidet sich von der ersten Variante nur im 
Rückgabewert. Was ist hier anders? Ich empfehle den Code zu studieren und 
zunächst selbst zu überlegen. 

Die Funktion `score_items2()` unterscheidet sich von der ersten Version dadurch, 
dass hier nicht an den ursprünglichen `data.frame` zusätzliche Spalten angehängt 
werden. Stattdessen werden die Spalten überschrieben! Das heißt: der ausgegebene 
`data.frame` hat dieselbe Zahl an Spalten wie die Eingabe, aber die Spalten 
enthalten nun die umkodierten Items (und zwar in der Reihenfolge, wie die Items 
auch eingegeben wurden). Betrachten wir die Funktion in Aktion: 

```{r}
items <- npi_clean[1:4, paste0("Q", 1:4)]
items
score_items2(items, keys[1:4])
```

Meiner Einschätzung nach wäre diese Variante der ersten Variante zu bevorzugen, 
aber beides ist in Ordnung. Im Endeffekt muss ja die Funktion nicht noch einmal 
die Ursprungsdaten zurückgeben -- diese haben wir ja schon.

### Version 3: Angabe der Spaltennamen

Wir die Ausgabe von `score_items2()` betrachten, merken wir, dass der 
ausgegebene `data.frame` natürlich dieselben Spaltennamen hat wie der 
eingegebene. Das kann unschön werden, wenn wir die umkodierten Spalten 
irgendwann wieder mit unseren anderen Daten in einem einzelnen `data.frame` 
zusammenführen wollen. Eine Möglichkeit dieses Problem zu umgehen, ist es
nachträglich mit der Funktion `colnames()`[^colnames] die Spaltennamen umzubenennen:

[^colnames]: Tatsächlich kann `colnames()` sowohl zum Auslesen als auch zum 
Schreiben von Spaltennamen verwendet werden; analoges gilt für die Funktionen 
`names()` und `rownames()`. 

```{r}
items_scored <- score_items2(items, keys[1:4])
items_scored
colnames(items_scored) <- paste0("Q", 1:4, "_scored")
items_scored
```

Wie folgt können wir dann übrigens die ursprünglichen und die umkodierten Items 
in einem data.frame wieder zusammenfügen:

```{r}
new_df <- data.frame(
  items,
  items_scored
)
new_df 
```

Aber zurück zur Funktion: wir können die Änderung der Spaltennamen auch zur 
Aufgabe der Funktion machen. Dann muss man es nicht jedes Mal nach dem Aufruf 
der Funktion erneut selbst machen. Hierfür können wir einen dritten Parameter 
hinzufügen, der zur Angabe der Spaltennamen dient. Ich definiere die Funktion 
nun wie folgt: 

```{r}
score_items3 <- function(df, keys, column_names = colnames(df)) {
  for (i in 1:ncol(df)) {
    df[[i]] <- ifelse(df[[i]] == keys[i], 1, 0)
  }
  colnames(df) <- column_names
  df
}
```

Was ich hier gemacht habe, mag erst einmal etwas seltsam aussehen. Dem Argument 
`column_names`, das innerhalb der Funktion die Spaltennamen anpasst, habe ich 
einen Standardwert zugewiesen habe. Und zwar handelt es sich bei dem 
Standardwert um die Spaltennamen des Parameters `df`. **Das ist eine legale 
Definition der Funktion.** Ich greife bei der Definition des Standardwerts auf 
einen anderen Parameter zu. Das heißt im Klartext: Im Normalfall verhält sich 
`score_items3()` genauso wie die Vorgängerversion `score_items2()`; die 
Spaltennamen werden genauso ausgegeben wie sie reingekommen sind. Aber: Mit 
`score_items3()` habe ich nun die Möglichkeit, die Spaltennamen anzupassen. Dann 
sollte dem Argument `column_names` ein Vektor vom Typ `character` übergeben 
werden, der die Spaltennamen enthält. Etwa so:

```{r}
score_items3(
  df = npi_clean[1:4, paste0("Q", 1:4)], 
  keys = keys[1:4], 
  column_names = paste0("coded", 1:4)
)
```

Sollte ich bevorzugen, dass die ausgegeben Spaltennamen sich im Standardfall 
schon von den eingegangenen unterscheiden, kann ich auch etwa wie folgt den 
Standardwert von `column_names` anpassen:

```{r}
score_items4 <- function(df, keys, 
                         column_names = paste0(colnames(df), "_recoded")) {
  for (i in 1:ncol(df)) {
    df[[i]] <- ifelse(df[[i]] == keys[i], 1, 0)
  }
  colnames(df) <- column_names
  df
}
```

Hier habe ich schon einigen Code verwendet, nur in der Definition des 
Standardwerts. Wenn wir nun `score_items4()` ohne Angabe von `column_names` 
aufrufen, erhalten wir folgende Ausgabe:

```{r}
score_items4(
  df = npi_clean[1:4, paste0("Q", 1:4)], 
  keys = keys[1:4]
)
```

Diese Variante der Funktion ist nützlich, wenn man sicherstellen will, dass man 
nicht die ursprünglichen Items mit den rekodierten Items verwechselt -- was 
schlimme Folgen haben kann, wenn es unbemerkt bleibt.
