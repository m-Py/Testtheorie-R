 
# Eigene Funktion: Bepunktung von Items

In diesem Kapitel geht es um eine konkrete Anwendung unserer bisher erworbenen 
Kenntnisse: Wir schreiben eine Funktion, die für beliebige Datensätze die 
Bepunktung von Testitems umsetzt. Dabei kombinieren wir die Inhalte aus den 
letzten beiden Kapitel zu Funktionen und zu Schleifen. Dabei gehe ich vor allem 
auf die Entscheidungen ein, die beim Schreiben einer Funktion getroffen werden 
müssen; es geht hier weniger um die technischen Aspekte der Definition von 
Funktionen, die wir bereits behandelt haben. 

## Problemspezifischer Code vs. abstrahierter Code

Eine Funktion zu schreiben bedeutet, ein gegebenes Problem zu 
abstrahieren.[^kopfanstrengen] Beim Schreiben einer Funktion entfernen wir uns 
von der konkreten Problematik einer einzelnen Aufgabe -- zumeist: dem Datensatz, 
den wir jetzt gerade bearbeiten. Stattdessen versuchen wir die Essenz des 
Problems zu begreifen und ein allgemeines Schema zur Lösung des Problems 
herzustellen. 

[^kopfanstrengen]: Das Schreiben einer Funktion erfordert zumeist etwas mehr 
(kognitiven) Aufwand als einfaches "dahin coden". Aber auf lange Sicht lohnt 
sich der Aufwand.

Die Bepunktung von Testitems bietet sich sehr gut als Beispiel für die 
"Extraktion" einer Funktion an, da die Problemstellung bei beliebigen 
Testinventaren auftritt und nicht nur während einer einzelnen Datenauswertung 
relevant ist. Betrachten wir noch einmal den Code zur Bepunktung der NPI-Items 
aus dem letzten Kapitel und überlegen, welche Bestandteile des Codes 
problemspezifisch sind. Alle problemspezifischen Aspekte müssen in einer 
Funktion entfernt werden, wobei die generelle Funktionalität des Codes erhalten 
bleiben muss.

```{r}
for (i in 1:40) {
  # 1. Wähle Spaltenname des i-ten Items aus:
  colname <- paste0("Q", i)
  # 2. Wähle aus Spalte die Antworten aus:
  ith_item <- npi_clean[[colname]]
  # 3. Führe Umkodierung durch:
  narcissistic_response <- ifelse(ith_item == keys[i], 1, 0)
  # 4. Erstelle Namen für neue Spalte:
  new_colname  <- paste0("coded", colname)
  # 5. Hänge kodierte Werte an data.frame an:
  npi_clean[[new_colname]] <- narcissistic_response
}
```

Welche Bestandteile dieses Codes sind problemspezifisch? Überlegt am besten 
zunächst selbst.

- Die Zahl der Schleifendurchläufe ist "hart kodiert" und nicht "dynamisch"; 
dieser Code nimmt per sé an, dass die Schleife 40 Mal laufen muss. Das liegt 
daran, dass das NPI aus 40 Items besteht und wir deswegen im letzten Kapitel 40 
Spalten bearbeitet haben. Eine Funktion, die mit beliebigen Testinventaren 
umgehen soll, kann `ncol()` nutzen, um die Zahl der zu bearbeitenden Spalten 
dynamisch auszulesen.
- Schritt 1 der Schleife greift auf die Spaltennamen des konkreten `data.frame`s 
zu, der hier bearbeitet wurde. Eine allgemein nutzbare Funktion sollte natürlich 
nicht davon ausgehen, dass die Namen in einem eingegebenen `data.frame` einem 
bestimmten Schema folgen. Die Spaltennamen sollten entweder per `colnames()` 
ausgelesen werden, oder wir adressieren die Spalten mit einem [numerischen 
Index](#indexadressierung).

Diese Erkenntnisse sind wichtig, um den problemspezifischen Code in eine 
allgemein nutzbare Funktion umzuwandeln. In einer Funktion wollen wir mit einem 
beliebigen `data.frame` arbeiten können. Dies impliziert unter anderem, dass wir 
dieser Funktion eine Tabelle übergeben müssen, die nur aus die Spalten der Items 
enthält, die tatsächlich umkodiert werden müssen. Oben enthält die Variable 
`npi_clean` auch noch weitere Spalten als die Items, beispielsweise Spalten zu 
demographischen Angaben. Einer Funktion würden wir einen reduzierten 
`data.frame` übergeben, in dem nur die Spalten der Items ausgelesen wurden -- 
alle anderen Spalten sind für das Problem nicht relevant. 

Im folgenden Beispiel habe ich den problemspezifischen Code schon etwas 
umgeschrieben und dabei alle problemspezifischen Aspekte entfernt. Es ist ein 
erster Schritt beim Umwandeln in eine Funktion. Der Code geht davon aus, dass 
der `data.frame`, der die umzukodierenden Items enthält, in einer Variablen `df` 
abgespeichert ist; die Schlüssel pro Item sollten in einem Vektor `keys` 
abgespeichert sein. 

```{r, eval = FALSE}

# Annahmen:
#   * `df` ist ein data frame, der die umzukodierenden Items enthält
#   * `keys` ist ein Vektor, der die Schlüssel enthält

n_items <- ncol(df) 

# Folgendes muss TRUE ergeben: `n_items == length(keys)`! Warum?

# Lies die Spaltennamen aus:
item_names <- colnames(df)

for (i in 1:n_items) {
    # Direkte Umkodierung des i'ten Items:
    coded_responses <- ifelse(df[[i]] == keys[i], 1, 0)
    # Hänge umkodierte Werte an den urspünglichen data frame an:
    new_colname <- paste0("coded_", item_names[i])
    df[[new_colname]] <- coded_responses
}

```

Indem wir die Variablen `df` und `keys` mit für uns angepassten Werten 
versehen, könnten wir den Code wiederholt aufrufen und damit in verschiedenen 
Datenauswertungen das Problem der Item-Umkodierung lösen. Etwa indem wir die 
folgenden Variablen definieren und danach den obigen Code ausführen -- probiert 
es aus!

```{r}
df <- npi_clean[, paste0("Q", 1:40)]
keys <- c(1, 1, 1, 2, 2, 1, 2, 1, 2, 2, 1, 1, 1, 1, 2, 1, 2, 2, 2, 2,
          1, 2, 2, 1, 1, 2, 1, 2, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 2)
```

Aber: der nächste Schritt, tatsächlich eine Funktion daraus zu bauen, macht den 
Code noch deutlich nützlicher. In einer Funktion wandeln wir die zwei Variablen 
aus dem obigen Code in Argumente um. Unsere Funktion sieht dann wie folgt aus: 

```{r}
score_items <- function(df, keys) {
    n_items <- ncol(df) 
    item_names <- colnames(df)
    for (i in 1:n_items) {
        coded_responses <- ifelse(df[[i]] == keys[i], 1, 0)
        new_colname <- paste0("coded_", item_names[i])
        df[[new_colname]] <- coded_responses
    }
    # Gib den data frame mit den zusätzlichen Spalten zurück:
    return(df)
}
```

Freunde von kürzerem Code können hier auch ein paar Zeilen sparen; etwa die 
folgende Definition der Funktion ist äquivalent: 

```{r}
score_items <- function(df, keys) {
    for (i in 1:ncol(df)) {
        col <- colnames(df)[i]
        df[[paste0("coded_", col)]] <- ifelse(df[[i]] == keys[i], 1, 0)
    }
    df # `return()` hier sogar gar nicht nötig
}
```

Probieren wir unseren Code mit dem NPI-Datensatz aus. Wir nutzen der Übersicht 
halber nur einen sehr kleinen Teil des Datensatzes (4 Personen + 4 Items):

```{r}
items <- npi_clean[1:4, paste0("Q", 1:4)]
items

items_scored <- score_items(items, keys[1:4])
items_scored
```

## Entscheidungen und Varianten

Funktionen zu schreiben bedeutet nicht nur die technische Seite zu beherrschen 
und ein Problem zu abstrahieren. Vielmehr stecken darin einige subjektive 
Entscheidungen, die die Nutzung der Funktion betreffen. Es ist zwar kein Zufall, 
wie ich oben die Funktion `score_items()` geschrieben habe, jedoch hätte sie 
auch ganz anders aussehen können. Damit meine ich nicht nur den Code im Körper 
der Funktion, sondern auch etwa, welche Argumente die Funktion annimmt und wie 
der Rückgabewert aussieht. 

Exemplarisch zeige ich im Folgenden einige Varianten dieser Funktion, die sich 
im Verhalten unterscheiden, obwohl in jedem Fall prinzipiell dasselbe geschieht: 
eine Funktion kodiert eine Sammlung von Testitems um. 

### Version 2: Keine Rückgabe der Ursprungsdaten

```{r}
score_items2 <- function(df, keys) {
  for (i in 1:ncol(df)) {
    df[[i]] <- ifelse(df[[i]] == keys[i], 1, 0)
  }
  df
}
```

Diese Variante der Funktion unterscheidet sich von der ersten Variante nur im 
Rückgabewert. Was ist hier anders? Ich empfehle den Code zu studieren und 
zunächst selbst zu überlegen. 

Die Funktion `score_items2()` unterscheidet sich von der ersten Version dadurch, 
dass hier nicht an den ursprünglichen `data.frame` zusätzliche Spalten angehängt 
werden. Stattdessen werden die Spalten überschrieben! Das heißt: der ausgegebene 
`data.frame` hat dieselbe Zahl an Spalten wie die Eingabe, aber die Spalten 
enthalten nun die umkodierten Items (und zwar in der Reihenfolge, wie die Items 
auch eingegeben wurden). Betrachten wir die Funktion in Aktion: 

```{r}
items <- npi_clean[1:4, paste0("Q", 1:4)]
items
score_items2(items, keys[1:4])
```

Meiner Einschätzung nach wäre diese Variante der ersten Variante zu bevorzugen, 
aber beides ist in Ordnung. Man könnte argumentieren, dass die Funktion nicht 
noch einmal die Ursprungsdaten zurückgeben muss -- diese haben wir ja schon, 
wenn wir sie aufrufen.

### Version 3: Angabe der Spaltennamen

Wir die Ausgabe von `score_items2()` betrachten, merken wir, dass ausgegebene 
`data.frame` dieselben Spaltennamen hat wie der eingegebene. Das kann unschön 
werden, wenn wir die umkodierten Spalten irgendwann wieder mit unseren anderen 
Daten in einem einzelnen `data.frame` zusammenführen wollen. Eine Möglichkeit 
dieses Problem zu umgehen, ist es nachträglich mit der Funktion 
`colnames()`[^colnames] die Spaltennamen umzubenennen:

[^colnames]: Tatsächlich kann `colnames()` sowohl zum Auslesen als auch zum 
Schreiben von Spaltennamen verwendet werden; analoges gilt für die Funktionen 
`names()` und `rownames()`. 

```{r}
items_scored <- score_items2(items, keys[1:4])
items_scored
colnames(items_scored) <- paste0("Q", 1:4, "_scored")
items_scored
```

Wie folgt können wir dann übrigens die ursprünglichen und die umkodierten Items 
in einem einzelnen `data.frame` wieder zusammenfügen:

```{r}
new_df <- data.frame(
  items,
  items_scored
)
new_df 
```

Wir können die Änderung der Spaltennamen auch zur Aufgabe der Funktion machen. 
In dem Fall müssen wir nicht jedes Mal nach dem Aufruf der Funktion erneut die 
Spaltennamen anpassen. Hierfür können wir ein drittes Argument hinzufügen, der 
zur Angabe der Spaltennamen dient. Ich definiere die Funktion nun wie folgt: 

```{r}
score_items3 <- function(df, keys, column_names = colnames(df)) {
  for (i in 1:ncol(df)) {
    df[[i]] <- ifelse(df[[i]] == keys[i], 1, 0)
  }
  colnames(df) <- column_names
  df
}
```

Was ich hier gemacht habe, sieht möglicherweise erst einmal etwas magisch aus. 
Dem Argument `column_names`, das innerhalb der Funktion die Spaltennamen 
anpasst, habe ich einen Standardwert zugewiesen -- und zwar handelt es sich bei 
dem Standardwert um die Spaltennamen des Arguments `df`. **Das ist eine legale 
Definition der Funktion.** Ich greife bei der Definition des Standardwerts auf 
ein anderes Argument zu. Das heißt im Klartext: Im Normalfall verhält sich 
`score_items3()` genauso wie die Vorgängerversion `score_items2()`; die 
Spaltennamen werden genauso ausgegeben wie sie reingekommen sind. Aber: Mit 
`score_items3()` habe ich nun die Möglichkeit, die Spaltennamen anzupassen. Dann 
sollte dem Argument `column_names` ein Vektor vom Typ `character` übergeben 
werden, der die Spaltennamen enthält. Etwa so:

```{r}
score_items3(
  df = npi_clean[1:4, paste0("Q", 1:4)], 
  keys = keys[1:4], 
  column_names = paste0("coded", 1:4)
)
```

### Version 4: Spaltennamen im Normalfall angepasst

Sollte ich bevorzugen, dass die ausgegeben Spaltennamen sich im Standardfall 
schon von den Spaltennamen aus dem eingegebenen `data.frame` unterscheiden, kann 
ich wie folgt den Standardwert von `column_names` anpassen:

```{r}
score_items4 <- function(
  df, keys, column_names = paste0(colnames(df), "_recoded")
) {
  for (i in 1:ncol(df)) {
    df[[i]] <- ifelse(df[[i]] == keys[i], 1, 0)
  }
  colnames(df) <- column_names
  df
}
```

Hier habe ich schon einigen Code verwendet, nur in der Definition des 
Standardwerts. Wenn wir nun `score_items4()` ohne Angabe von `column_names` 
aufrufen, erhalten wir folgende Ausgabe:

```{r}
score_items4(
  df = npi_clean[1:4, paste0("Q", 1:4)], 
  keys = keys[1:4]
)
```

Diese Variante der Funktion ist nützlich, wenn man sicherstellen will, dass man 
nicht die ursprünglichen Items mit den rekodierten Items verwechselt -- was 
schlimme Folgen haben kann, wenn es unbemerkt bleibt.

### Version 5: Auswahl der Spalten innerhalb der Funktion

Wir haben bislang der Funktion immer einen `data.frame` übergeben, der nur aus 
den relevanten Spalten bestand, also den Spalten, die Testitems beinhalten. Wir 
können die Auswahl der Spalten jedoch auch der Funktion überlassen. Dies lässt 
sich sogar durch eine relativ einfache Anpassung umsetzen: 

```{r}
score_items5 <- function(df, keys, selection) {
  df <- df[, selection]
  for (i in 1:ncol(df)) {
    df[[i]] <- ifelse(df[[i]] == keys[i], 1, 0)
  }
  df
}
```

In diesem Fall ist das zusätzliche Argument `selection` ein Vektor, der die 
relevanten Spalten aus dem ursprünglichen `data.frame` auswält -- nach den uns 
aus [Kapitel 3](#datenzugriffe) bekannten Regeln. 

Wir können die Funktion wie folgt bedienen:

```{r}
score_items5(
  df = npi_clean[1:4, ], 
  keys = keys[1:4],
  selection = paste0("Q", 1:4)
)
```

### Version 6: Auswahl der Spalten nur optional

Die Funktion `score_items5()` lässt sich etwas holprig bedienen, wenn man 
eigentlich gar keine Spaltenauswahl betreiben will, wenn man ohnehin nur die 
relevanten Spalten übergibt. Das Argument `selection` ist nämlich nicht optional 
und die Funktion gibt einen Fehler aus, wenn es nicht spezifiziert wird.

Eine Möglichkeit das Argument optional zu machen für den Fall, dass die Funktion 
keine Spaltenauswahl durchführen soll ist folgende:

```{r, eval = FALSE}
score_items6 <- function(df, keys, selection = TRUE) {
  df <- df[, selection]
  for (i in 1:ncol(df)) {
    df[[i]] <- ifelse(df[[i]] == keys[i], 1, 0)
  }
  df
}
```

Wird das Argument `selection` nicht angegeben, werden im Standardfall durch den 
Befehl `df[, TRUE]` alle Spalten aus `df` ausgegeben (und wiederum in die 
Variable `df` geschrieben).

Eine Konvention in der `R`-Community ist es manchmal diese Art von optionalen 
Argumenten mit dem Wert `NULL` auszustatten. Innerhalb der Funktion kann dann 
mit der Programmierstruktur `if{}/else{}` überprüft werden, ob das Argument 
existiert. 

```{r, eval = FALSE}
score_items6 <- function(df, keys, selection = NULL) {
  if (is.null(selection)) { # `selection` wurde nicht spezifiziert
    df <- df
  } else { # `selection` wurde spezifiziert
    df <- df[, selection]
  }
  for (i in 1:ncol(df)) {
    df[[i]] <- ifelse(df[[i]] == keys[i], 1, 0)
  }
  df
}
```

Die `if{}/else{}`-Struktur ist eine der grundlegenden Programmierstrukturen in 
`R` (und anderen Programmiersprachen). Sie kommt oftmals in Funktionen in 
Einsatz, gerade um das Verhalten der Funktion in Abhängigkeit von Argumenten 
anzupassen. Code, der dem Schlagwort `if` folgt, wird nur dann ausgeführt, wenn 
der Befehl in der folgenden Klammer `TRUE` ergibt; hier wird der Ausdruck 
`is.null(selection)` geprüft, der nur dann `TRUE` ergibt, wenn die Variable 
`selection` den Wert `NULL` hat. Ist das nicht der Fall -- also wenn 
`is.null(selection)` den Wert `FALSE` ergibt --, wird der Code nach `else` 
ausgeführt. Beachtet, dass **nicht** auf jedes `if` ein `else` folgen 
muss.[^elseif] Dieser Code etwa wäre eleganter und benötigt kein `else` um 
dasselbe Ergebnis zu erzielen: 

[^elseif]: Es existiert auch das Schlagwort `else if{}`. Ich schlage an dieser 
Stelle vor, zu den wichtigen Programmierelementen `if{}/else{}` und `else if{}` 
eine Internetrecherche durchzuführen, um weitere Informationen zu sammeln. 

```{r, eval = FALSE}
score_items6 <- function(df, keys, selection = NULL) {
  if (!is.null(selection)) { # `selection` wurde spezifiziert
    df <- df[, selection]
  }
  for (i in 1:ncol(df)) {
    df[[i]] <- ifelse(df[[i]] == keys[i], 1, 0)
  }
  df
}
```

Dass optionale Argument mit dem Wert `NULL` definiert werden ist reine 
Konvention; erfahrenere `R`-Nutzer erkennen an dem Ausdruck `selection = NULL`, 
dass dem Argument `selection` innerhalb der Funktion ein Standardwert zugewiesen 
wird. 

## Dokumentation von Funktionen {#docs}

Die Dokumentation von Code ist ein wichtiges Thema, das ich in diesem Kapitel 
kaum zur Genüge behandeln kann. Gerade bei Funktionen ist eine Dokumentation 
essentiell, al­ler­min­des­tens im Rahmen von Kommentaren im Code. Auch wenn ihr 
selbst die einzigen "Nutzer" eurer Funktion seid, müsst ihr deren Funktionsweise 
dokumentieren; euer zukünftiges Ich wird euch andernfalls verfluchen, nachdem ihr 
eure eigene Funktion ein paar Wochen nicht verwendet habt.

Bei der Dokumentation einer Funktion sollten alle Aspekte des 
[Black-Box-Modells](#funktionen) abdeckt werden. Insbesondere muss dokumentiert 
sein, welche Daten als Argumente übergeben werden müssen, welche der Argumente 
optional sind, und was das Standardverhalten der optionalen Argumente ist. Eine 
Dokumentation der Rückgabe ist auch wünschenswert, aber etwas weniger wichtig 
(die Ausgabe kann im Zweifel noch nach Aufruf inspiziert werden). Seiteneffekte 
sollten vermieden werden und müssen deshalb nicht dokumentiert 
werden.[^docsseiteneffekte] Alle hier diskutierten Funktionen haben keine 
Seiteneffekte; das einzige, was sie nach außen abgegeben wird, ist der explizit 
vorgesehene Rückgabewert. Entsprechend des Black-Box-Modell ist es weniger 
wichtig die interne Funktionsweise einer Funktion zu dokumentieren. Kommentare 
im Code von Funktionen sind aber wie immer willkommen. 

[^docsseiteneffekte]: Sollte die Funktion Seiteneffekte haben, müssen sie 
natürlich dokumentiert werden. 

Im Folgenden ein Beispiel zur Dokumentation der Funktion `score_items4()`

```{r}

# score_items4: Eine Funktion zur Bepunktung von Testitems
#
# Argument 1: `df` - ein data frame, dessen Spalten die Items
#              des Tests sind. Enthält die rohen Antworten, die umkodiert 
#              werden sollen.
# Argument 2: `keys` - Ein Vektor, der pro Item den Schlüssel enthält. 
#              Dabei kodiert der i'te Eintrag in `keys` den Schlüssel 
#              zum i'ten Item (also der i'ten Spalte) in `df`. Es gilt 
#              `ncol(df) == length(keys)`!
# Argument 3: `column_names` - Optionales Argument. Ein Vektor vom Typ 
#             character, der die Spalten des ausgegebenen data frames 
#             benennt. Im Normalfall (also, wenn das Argument nicht 
#             spezifiziert wird): Verwendet die Spaltennamen von `df` 
#             und hängt "_recoded" an.
#            
# Ausgabe: Ein data frame, der dieselben Dimensionen hat wie die Eingabe 
#          `df` Antworten wurden entsprechend des Schlüssels umkodiert, 
#          d.h. eine 1 zeigt an, dass die Antwort dem Schlüssel entsprach, 
#          andernfalls wird eine 0 ausgegeben. 

score_items4 <- function(
  df, keys, column_names = paste0(colnames(df), "_recoded")
) {
  for (i in 1:ncol(df)) {
    df[[i]] <- ifelse(df[[i]] == keys[i], 1, 0)
  }
  colnames(df) <- column_names
  df
}
```

Wichtig ist eine inhaltliche Beschreibung der Funktionsargumente und auch eine 
technische Beschreibung. 

Eine etwas formalisiertere Variante der Dokumentation von Funktionen bietet das 
Paket [`roxygen2`](https://roxygen2.r-lib.org/). Dieses ist jedoch vor allem 
dann relevant, wenn man eigene R-Pakete schreibt. Für die ersten eigenen 
Funktionen reicht es, wie hier im Beispiel, Code-Kommentare zu nutzen, um eine 
Funktion zu dokumentieren. 

## Validierung der Eingabe {#inputvalidation}

Es ist gute Praxis, beim Schreiben von Funktionen ein paar Überprüfungen 
einzuführen, die sicherstellen, dass die Argumente korrekt angegeben wurden. 
Solche Überprüfungen verhindern potenzielle Fehler. Mögliche Überprüfungen 
könnten im vorliegenden Fall sein: 

- Hat der Vektor `keys` dieselbe Länge wie der das Argument `df` Spalten hat? 
Bei den Varianten 5 und 6 müsste dies **nach** der Spaltenauswahl geprüft 
werden, da ja potentiell Spalten ausgeschlossen werden.
- Haben die Daten die korrekte Struktur und den korrekten Datentyp? Ist `keys` 
ein Vektor, `df` ein `data.frame`, sind darin sinnvolle Werte enthalten (etwa: 
nur numerische Werte im legalen Bereich?)

Bei solchen Überprüfungen kommen die `if{}/else{}`-Befehle zum Einsatz. Wenn 
eine problematische Eingabe festgestellt wird, kann die Funktion `stop()` 
genutzt werden, um einen Fehler auszugeben. Es bietet sich etwa folgende 
Überprüfung an: 

```{r, eval = FALSE}
score_items6 <- function(df, keys, selection = NULL) {
  if (!is.null(selection)) { # `selection` wurde spezifiziert
    df <- df[, selection]
  }
  if (ncol(df) != length(keys)) {
    stop("Die Spaltenzahl in `df` passt nicht zur Laenge von `keys`.")
  }
  for (i in 1:ncol(df)) {
    df[[i]] <- ifelse(df[[i]] == keys[i], 1, 0)
  }
  df
}
```

In diesem Fall wird der Aufruf der Funktion `score_items6()` abgebrochen, wenn 
die Argumente `df` und `keys` nicht zusammenpassen. Dies stellt ein Aufruf der 
Funktion `stop()` sicher, die in diesem Fall auch eine diagnostische 
Fehlermeldung ausgibt. 

Ich werde an dieser Stelle nicht tiefer auf die Überprüfung von Argumenten 
eingehen. Denkt aber daran immer, dass solche Überprüfungen wichtig sind und 
euch gravierende Fehler ersparen können. Welche Prüfungen Sinn machen, hängt 
immer von dem konkreten Anwendungsfall ab.

## Abschließender Hinweis: Matritzen {#matritzen}

Wer die oben definierte Funktion zur Bepunktung von Items selbst nutzen 
will, verwendet besser folgende Abwandlung: 

```{r}
score_items <- function(
  df, keys, 
  column_names = NULL, 
  selection = TRUE
) {
  # Ggf.: Spaltenauswahl
  df <- df[, selection]
  # Ändere ggf. die Spaltennamen:
  if (is.null(column_names)) {
    column_names <- paste0(colnames(df), "_recoded")
  }
  # Ein wenig Input-Validierung:
  if (length(column_names) != ncol(df)) {
    stop("Die Spaltennamen wurden nicht korrekt spezifiziert.")
  }
  if (ncol(df) != length(keys)) {
    stop("Die Spaltenzahl in `df` passt nicht zur Laenge von `keys`.")
  }
  # Eigentliche Bepunktung:
  for (i in 1:ncol(df)) {
    df[, i] <- ifelse(df[, i] == keys[i], 1, 0)
  }
  # Spaltennamen setzen:
  colnames(df) <- column_names
  # Rückgabe:
  df
}
```

In dieser "finalen" Version habe ich noch ein paar zusätzliche Überprüfungen 
eingebaut; außerdem enthält die Funktion nun sowohl das Argument `column_names` 
als auch das Argument `selection`. Betrachtet genau, wie diese Argumente nun 
in der Funktion verarbeitet werden. 

Der Unterschied, auf den ich vor allem aufmerksam machen möchte, ist aber noch 
ein anderer. Betrachtet die Art, in der nun die Spalten adressiert werden: Hier 
verwende ich die `[·,·]`-Notation und nicht mehr die `[[·]]`-Notation zur 
Auswahl von Spalten aus `df`. Der Grund hierfür ist, dass die `[·,·]`-Notation 
allgemeiner ist. Sie funktioniert auch dann, wenn die Eingabe `df` eine Matrix 
ist und kein `data.frame`. Eine Matrix ist eine weitere Datenstruktur in `R`, 
die strukturell äquivalent zu einem `data.frame` ist: Sowohl Matritzen als auch 
`data.frames` sind zweidimensionale Tabellen bestehend aus Zeilen und Spalten. 
Jedoch muss in einer Matrix jede Spalte -- und damit sogar jede einzelne Zelle 
-- denselben Datentyp haben, wie wir es aus einem Vektor kennen (siehe auch die 
Hilfe in `?matrix`). Wenn Antworten auf Testitems numerisch kodiert sind, können 
diese also sowohl als `data.frame` als auch als Matrix vorliegen.

In Matritzen lassen sich Spalten nicht mit der `$`-Notation oder der 
`[[·]]`-Notation auswählen, stattdessen *muss* die `[·,·]`-Notation genutzt 
werden. Die `$`-Notation funktioniert gar nicht, die `[[·]]`-Notation kann ein 
unerwartetes Ergebnis ergeben, da sie nur ein Element auswählen würde und nicht 
eine ganze Spalte.[^matrixistvektor]

[^matrixistvektor]: Technisch gesehen ist eine Matrix ein simpler Vektor, dem 
intern die Dimensionen Reihe/Spalte zugeordnet werden. Die `[[·]]`- und die 
`[·]`-Notationen betrachten die Matrix als einen eindimensionalen Vektor. 
Demnach geben beispielsweise die Befehle `mat[2]` oder `mat[[2]]` das zweite 
Element aus diesem zugrundeliegenden Vektor aus -- und nicht die zweite Spalte 
der eigentlich Matrix. Eine interessante Frage ist nun: Was ist in einer Matrix 
das *zweite* Element? Möglich wäre: Der Wert in der ersten Zeile, zweite Spalte, 
oder der Wert in der zweiten Zeile, erste Spalte. In `R` ist letzteres der Fall, 
also der Wert in der zweiten Zeile. Der zugrundeliegende Vektor speichert zu 
Beginn erste Spalte ab, danach die zweite Spalte, usw. Man sagt, Matritzen 
werden in "column major order" in Vektorenform abgespeichert. 

Matritzen stellen in `R` eine wichtige Datenstruktur dar. Viele mathematische 
Funktionen arbeiten eher mit Matritzen als mit `data.frames`.[^switchbetween] 
Beispielsweise gibt die Funktion `cor()`, wenn man die Inter-Itemkorrelationen 
zwischen mehreren Items anfordert, eine Matrix und keinen `data.frame` zurück. 
In solchen Fällen müssen wir auf der Hut sein; ein typischer Fehler ist der 
Versuch, mit der `$`-Notation Spalten aus Matritzen auszulesen, was fehlschlägt. 
Wir haben bislang mit `data.frames` gearbeitet, da Forschungsdaten im Normalfall 
immer als `data.frame` vorliegen -- man benötigt eben im Normalfall mehrere 
Datentypen in einer Datentabelle. Da einige Funktionen aber Matritzen 
zurückgeben, ist es nützlich diesen Datentyp zu kennen. 

[^switchbetween]: Mit den Funktionen `as.matrix()` und `as.data.frame()` ist es 
recht einfach, die beiden Datenstrukturen ineinander überzuführen.

## Fragen und Übungen zum vertiefenden Verständnis

1. Dokumentiert die [finale Version](#matritzen) der Funktion `score_items()`, indem 
ihr das [Schema für die Funktion `score_items4()`](#docs) anpasst. Geht 
insbesondere auf der Verhalten der optionalen Argumente `column_names` und 
`selection` ein. 
2. Wie kann die finale Version der Funktion `score_items()` bedient werden, 
sodass die ausgegebene Tabelle dieselben Spaltennamen hat wie die eingegebene?
3. Ändert die finale Funktion `score_items()` in eine neue Variante um. Nun soll 
`keys` [ein benannter Vektor](#nameindex) sein, dessen Namen den (relevanten) 
Spaltennamen im Argument `df` entsprechen. Im Körper der Funktion soll die 
Auswahl der Spalten aus `df` als auch der Einträge aus `keys` [nach 
Name](#nachname) stattfinden. Solch Adressierung nach Namen ist im Allgemeinen 
weniger fehleranfällig als die Adressierung nach Index -- insbesondere dann, 
wenn die relevanten Spalten erst in der Funktion selbst ausgewählt werden (mit 
dem Argument `selection`).
4. Dokumentiert die aktualisierte Funktion aus Aufgabe 3. Worauf muss ein Nutzer 
der Funktion nun aufmerksam gemacht werden?
5. Fügt in eure Funktion aus Aufgabe 3 weitere Überprüfungen der Eingabe ein. 
Wenn ihr Fehler in der Eingabe feststellt, nutzt die Funktion `stop()`, um einen 
Fehler und eine sinnvolle Fehlermeldung auszugeben. Zu den [oben 
diskutierten](#inputvalidation) Fehlerprüfungen macht noch folgendes Sinn: 
Passen die Namen des Vektors `keys` zu den Spaltennamen in `df`? Hier ist 
gegebenenfalls etwas Recherche nötig, um herauszufinden, wie die Namen zwischen 
den beiden Objekten abgeglichen werden können. 
